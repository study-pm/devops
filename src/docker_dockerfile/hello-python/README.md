# Writing Dockerfile with Hello Python Script Added
https://dockerlabs.collabnix.com/beginners/dockerfile/lab_dockerfile_python.html

- [Assignment](#assignment)
- [Command Line Tools](#command-line-tools)
  - [Start the service](#start-the-service)
  - [Stop the service](#stop-the-service)
  - [Underlying commands](#underlying-commands)
    - [Pre-requisite](#pre-requisite)
    - [Writing a Dockerfile](#writing-a-dockerfile)
      - [Setting a Base Image using `FROM` keyword](#setting-a-base-image-using-from-keyword)
      - [Defining the Author (Optional) using `MAINTAINER` keyword](#defining-the-author-optional-using-maintainer-keyword)
      - [Running a commands on the base image to form new layers using `RUN` keyword](#running-a-commands-on-the-base-image-to-form-new-layers-using-run-keyword)
      - [Adding a simple Hello World printing python file to the container’s file system using `ADD` command](#adding-a-simple-hello-world-printing-python-file-to-the-containers-file-system-using-add-command)
      - [Specifying default execution environment for the container using `CMD` and `ENTRYPOINT`](#specifying-default-execution-environment-for-the-container-using-cmd-and-entrypoint)
    - [Building a Dockerfile](#building-a-dockerfile)
    - [Running a container from the newly built image](#running-a-container-from-the-newly-built-image)
      - [Running with `CMD` default](#running-with-cmd-default)
      - [Running with `CMD` overriden](#running-with-cmd-overriden)
- [Utils / Trivia](#utils--trivia)
  - [Images](#images)
    - [Build image](#build-image)
    - [Browse image history](#browse-image-history)
    - [Remove images](#remove-images)
  - [Containers](#containers)
    - [Create (run) a container](#create-run-a-container)
    - [List containers](#list-containers)
    - [Exit the container shell](#exit-the-container-shell)
    - [Remove containers](#remove-containers)
    - [Remove a container](#remove-a-container)
    - [Force-remove a running container (`--force`)](#force-remove-a-running-container---force)
    - [Remove all stopped containers](#remove-all-stopped-containers)
  - [Volumes](#volumes)
    - [Create a volume](#create-a-volume)
    - [List volumes](#list-volumes)
    - [Inspect volume](#inspect-volume)
    - [Remove volumes](#remove-volumes)
- [Troubleshooting](#troubleshooting)
  - [Fix `permission denied` error](#fix-permission-denied-error)
  - [Fix `failed to read dockerfile` error](#fix-failed-to-read-dockerfile-error)

## Assignment
- Write a *Dockerfile*
- Build a *Dockerfile*
- Run a container from the newly built image

## Command Line Tools
There are two prime commands for managing (starting and stopping) the provided service.

### Start the service
The following command runs the full command sequence:
```sh
$ ./start
```

alternatively:
```sh
$ sh start
```

### Stop the service
The following command clears all of the output (removing all possible side-effects) generated by running the *start* command:
```sh
$ ./clear
```

alternatively:
```sh
$ sh clear
```

### Underlying commands
There are multiple underlying scripts used for building the service functions. The sections below describe the commands used for managing the provided service and building the necessary resources.

#### Pre-requisite
There should be the following files in your working directory:
- *Dockerfile* (committed)
- *hello.py* (committed)
- *a.py* (committed)

In case any of them missing, run the *[create.sh](./create.sh)* script before executing the *start* command.

All temporary files are removed on running the *[clear.sh](./clear.sh)* script

#### Writing a Dockerfile
```sh
[node1] (local) root@192.168.0.38 ~
$ mkdir /test
```
```sh
[node1] (local) root@192.168.0.38 ~
$ cd /test
```
```sh
[node1] (local) root@192.168.0.38 /test
$ pwd
/test
```
Open a file named ‘Dockerfile’ with a text editor.
```sh
[node1] (local) root@192.168.0.38 /test
$ vi Dockerfile
```

##### Setting a Base Image using `FROM` keyword
```docker
FROM ubuntu
```

Thus, our image would start building taking base as Ubuntu.

##### Defining the Author (Optional) using `MAINTAINER` keyword
```docker
MAINTAINER Prashansa Kulshrestha
```

##### Running a commands on the base image to form new layers using `RUN` keyword
```docker
RUN apt-get update
RUN apt-get install python
```

Since, the base image was Ubuntu, we can run Ubuntu commands here. These commands above install python over Ubuntu.

##### Adding a simple Hello World printing python file to the container’s file system using `ADD` command
```docker
ADD hello.py /home/hello.py
ADD a.py /home/a.py
```
We will place our *hello.py* and *a.py* files in the newly created directory itself (*/test*). `ADD` command would copy it from */test* (current working directory) of host system to container’s filesystem at */home*. The destination directories in the container would be created incase they don’t exist.

Code for *hello.py*:
```py
print ("Hello World")
```
Code for *a.py*:
```py
print ("Overriden Hello")
```

##### Specifying default execution environment for the container using `CMD` and `ENTRYPOINT`
These keywords let us define the default execution environment for a container when it just initiates from an image or just starts. If a command is specified with `CMD` keyword, it is the first command which a container executes as soon as it instantiates from an image. However, command and arguments provided with `CMD` can be overridden if user specifies his own commands while running the container using `docker run` command.

`ENTRYPOINT` helps to create a executable container and the commands and arguments provided with this keyword are not overridden.

We can also provide the default application environment using `ENTRYPOINT` and default arguments to be passed to it via `CMD` keyword. This can be done as follows:
```docker
CMD ["/home/hello.py"]
ENTRYPOINT ["python"]
```

So, default application mode of container would be python and if no other filename is provided as argument to it then it will execute *hello.py* placed in its */home* directory.

Benefit of this is that user can choose some other file to run with the same application at runtime, that is, while launching the container.

So, our overall Dockerfile currently looks like this:

*Dockerfile*
```docker
FROM ubuntu
MAINTAINER Prashansa Kulshrestha
RUN apt-get update
RUN apt-get install -y python
ADD hello.py /home/hello.py
ADD a.py /home/a.py
CMD ["/home/hello.py"]
ENTRYPOINT ["python"]
```

Placed into *[create.sh](./create.sh)*.

#### Building a Dockerfile
To create an image from the *Dockerfile*, we need to build it. This is done as follows:
```sh
[node1] (local) root@192.168.0.38 /test
$ docker build -t pythonimage .
```

The option `-t` lets us tag our image with a name we desire. So, here we have named our image as ‘pythonimage’. The `.` in the end specifies current working directory i.e. */test*. We initiated our build process from here. Docker would find the file named ‘Dockerfile’ in the current directory to process the build.

Placed into *[build.sh](./build.sh)*.

#### Running a container from the newly built image

##### Running with `CMD` default
```sh
[node1] (local) root@192.168.0.38 /test
$ docker run --name test1 pythonimage
Hello World
[node1] (local) root@192.168.0.38 /test
$
```

Placed into *[run.sh](./run.sh)*.

So, here */home/hello.py* file placed in the container executed and displayed the output ‘Hello World’, since it was specified as default with `CMD` keyword.

##### Running with `CMD` overriden
```sh
[node1] (local) root@192.168.0.38 /test
$ docker run --name test2 pythonimage /home/a.py
Overriden Hello 
[node1] (local) root@192.168.0.38 /test
$
```

Here, user specified another file to be run with python (default application for this container). So, the file specified with CMD got overridden and we obtained the output from */home/a.py*.

## Utils / Trivia

### Images

#### Build image
```sh
$ docker image build -t <tag> .
$ docker build -t <tag> . -f <dockerfile-name>
```

#### Browse image history
```sh
$ docker image history <image>

#### List images
```sh
# Lists all images
$ docker images
$ docker image ls

# List a specific image
$ docker images <image>
$ docker image ls <image>
$ docker images | grep "keyword(s)"
```

#### Remove images
Below are the three command aliases:
```sh
$ docker image remove <image>
$ docker image rm <image>
$ docker rmi <image>
```

### Containers

#### Create (run) a container
```sh
$ docker container run <image>
$ docker run <image>
```

#### List containers
```sh
# List running containers
$ docker ps
$ docker container ls

# Lists all (running and stopped) containers
$ docker ps -a
```

#### Exit the container shell
Press <kbd>Ctrl</kbd> + <kbd>c</kbd> to exit the container shell. This stops the running container.

If you want to detach from a container without stopping it, type <kbd>Ctrl</kbd> + <kbd>p</kbd> then <kbd>Ctrl</kbd> + <kbd>q</kbd>. It will help you to turn interactive mode to daemon mode.

#### Remove containers
https://docs.docker.com/reference/cli/docker/container/rm/

#### Remove a container
This removes the container referenced under the link `/redis`.
```sh
$ docker rm /redis

/redis
```

#### Force-remove a running container (`--force`)
This command force-removes a running container.
```sh
$ docker rm --force redis

redis
```

The main process inside the container referenced under the link `redis` will receive `SIGKILL`, then the container will be removed.

#### Remove all stopped containers
Use the [`docker container prune`](https://docs.docker.com/reference/cli/docker/container/prune/) command to remove all stopped containers, or refer to the [`docker system prune`](https://docs.docker.com/reference/cli/docker/system/prune/) command to remove unused containers in addition to other Docker resources, such as (unused) images and networks.

Alternatively, you can use the `docker ps` with the `-q` / `--quiet` option to generate a list of container IDs to remove, and use that list as argument for the `docker rm` command.

Combining commands can be more flexible, but is less portable as it depends on features provided by the shell, and the exact syntax may differ depending on what shell is used. To use this approach on Windows, consider using PowerShell or Bash.

The example below uses `docker ps -q` to print the IDs of all containers that have exited (`--filter status=exited`), and removes those containers with the `docker rm` command:
```sh
$ docker rm $(docker ps --filter status=exited -q)
```

Or, using the `xargs` Linux utility:
```sh
$ docker ps --filter status=exited -q | xargs docker rm
```

### Volumes
https://docs.docker.com/reference/cli/docker/volume/

Manage volumes. Usage: `docker volume COMMAND`

#### Create a volume
```sh
$ docker volume create
```

#### List volumes

```sh
$ docker volume ls
```

Show names and mount point destinations of volumes used by a container:
https://stackoverflow.com/questions/30133664/how-do-you-list-volumes-in-docker-containers

```sh
$ docker container inspect \
 -f '{{ range .Mounts }}{{ .Name }}:{{ .Destination }} {{ end }}' \
 <CONTAINER_ID_OR_NAME>
```

#### Inspect volume

```sh
$ docker volume inspect
```

#### Remove volumes
Remove unused local volumes:
```sh
# With confirmation dialogue
$ docker volume prune

# Without confirmation
$ docker volume prune -f
```

Remove one or more volumes:
```sh
$ docker volume rm <volumes>
```

## Troubleshooting

### Fix `permission denied` error
If you get the *permission denied* error while building the service scripts, make the script file executable:
```sh
$ chmod +x start
```

or:
```
$ chmod u+x clear
```

### Fix `failed to read dockerfile` error
If you get the *ERROR: failed to solve: failed to read dockerfile* error while running the service, probably you have your *Dockerfile* or other crucial static files missing. Run the *[create.sh](./create.sh)* script before executing the *start* command.
