# Lab #6: WORKDIR instruction
https://dockerlabs.collabnix.com/beginners/dockerfile/WORKDIR_instruction.html

The `WORKDIR` directive in *Dockerfile* defines the working directory for the rest of the instructions in the Dockerfile. The `WORKDIR` instruction won't create a new layer in the image but will add metadata to the image config. If the `WORKDIR` doesn’t exist, it will be created even if it’s not used in any subsequent *Dockerfile* instruction. You can have multiple `WORKDIR` in same Dockerfile. If a relative path is provided, it will be relative to the previous `WORKDIR` instruction.
```docker
WORKDIR /path/to/workdir
```

If no `WORKDIR` is specified in the Dockerfile then the default path is `/`. The `WORKDIR` instruction can resolve environment variables previously set in *Dockerfile* using `ENV`.

- [Assignment](#assignment)
- [Command Line Tools](#command-line-tools)
  - [Start the service](#start-the-service)
  - [Stop the service](#stop-the-service)
  - [Underlying commands](#underlying-commands)
    - [Pre-requisite](#pre-requisite)
    - [Dockerfile with `WORKDIR` instruction](#dockerfile-with-workdir-instruction)
      - [Create Dockerfile](#create-dockerfile)
      - [Building Docker image](#building-docker-image)
      - [Testing current `WORKDIR` by running container](#testing-current-workdir-by-running-container)
    - [`WORKDIR` with relative path](#workdir-with-relative-path)
      - [Create Dockerfile](#create-dockerfile-1)
      - [Building Docker image](#building-docker-image-1)
      - [Testing current `WORKDIR` by running container](#testing-current-workdir-by-running-container-1)
    - [`WORKDIR` with Absolute path](#workdir-with-absolute-path)
      - [Create Dockerfile](#create-dockerfile-2)
      - [Building Docker image](#building-docker-image-2)
      - [Testing current `WORKDIR` by running container](#testing-current-workdir-by-running-container-2)
    - [`WORKDIR` with environment variables as path](#workdir-with-environment-variables-as-path)
      - [Create Dockerfile](#create-dockerfile-3)
      - [Building Docker image](#building-docker-image-3)
      - [Testing current `WORKDIR` by running container](#testing-current-workdir-by-running-container-3)
- [Utils / Trivia](#utils--trivia)
  - [Images](#images)
    - [List images](#list-images)
    - [Remove images](#remove-images)
  - [Containers](#containers)
    - [List containers](#list-containers)
    - [Exit the container shell](#exit-the-container-shell)
    - [Remove containers](#remove-containers)
    - [Remove a container](#remove-a-container)
    - [Force-remove a running container (`--force`)](#force-remove-a-running-container---force)
    - [Remove all stopped containers](#remove-all-stopped-containers)
- [Troubleshooting](#troubleshooting)
  - [Fix `permission denied` error](#fix-permission-denied-error)
  - [Fix `failed to read dockerfile` error](#fix-failed-to-read-dockerfile-error)

## Assignment
- Dockerfile with `WORKDIR` instruction
- `WORKDIR` with Relative path
- `WORKDIR` with Absolute path
- `WORKDIR` with environment variables as path

## Command Line Tools
There are two prime commands for managing (starting and stopping) the provided service.

### Start the service
The following command runs the full command sequence:
```sh
$ ./start
```

alternatively:
```sh
$ sh start
```

### Stop the service
The following command clears all of the output (removing all possible side-effects) generated by running the *start* command:
```sh
$ ./clear
```

alternatively:
```sh
$ sh clear
```

### Underlying commands
There are multiple underlying scripts used for building the service functions. The sections below describe the commands used for managing the provided service and building the necessary resources.

#### Pre-requisite
There should be the following files (committed) in your working directory:
- *build1.Dockerfile*
- *build2.Dockerfile*
- *build3.Dockerfile*
- *build4.Dockerfile*

In case any of them missing, run the *[create.sh](./create.sh)* script before executing the *start* command.

#### Dockerfile with `WORKDIR` instruction

##### Create Dockerfile
*Dockerfile*
```docker
FROM alpine:3.9.3
LABEL maintainer="Collabnix"

WORKDIR /opt
```

Placed into *[create.sh](./create.sh)*.

##### Building Docker image

```sh
$ docker build -t workdir:v1 .
```

Placed into *[build.sh](./build.sh)*.

##### Testing current `WORKDIR` by running container

```sh
$ docker run -it workdir:v1 pwd
```

Placed into *[run.sh](./run.sh)*.

#### `WORKDIR` with relative path

##### Create Dockerfile
*Dockerfile*:
```docker
FROM alpine:3.9.3
LABEL maintainer="Collabnix"

WORKDIR /opt
RUN echo "Welcome to Docker Labs" > opt.txt
WORKDIR folder1
RUN echo "Welcome to Docker Labs" > folder1.txt
WORKDIR folder2
RUN echo "Welcome to Docker Labs" > folder2.txt
```

Placed into *[create.sh](./create.sh)*.

##### Building Docker image

```sh
$ docker build -t workdir:v2 .
```

Placed into *[build.sh](./build.sh)*.

##### Testing current `WORKDIR` by running container

```sh
$ docker run -it workdir:v2 pwd
```

Placed into *[run.sh](./run.sh)*.

#### `WORKDIR` with Absolute path

##### Create Dockerfile
*Dockerfile*:
```
FROM alpine:3.9.3
LABEL maintainer="Collabnix"

WORKDIR /opt/folder1
RUN echo "Welcome to Docker Labs" > opt.txt
WORKDIR /var/tmp/
```

Placed into *[create.sh](./create.sh)*.

##### Building Docker image

```sh
$ docker build -t workdir:v3 .
```

Placed into *[build.sh](./build.sh)*.

##### Testing current `WORKDIR` by running container

```sh
$ docker run -it workdir:v3 pwd
```

Placed into *[run.sh](./run.sh)*.

#### `WORKDIR` with environment variables as path

##### Create Dockerfile
*Dockerfile*:
```
FROM alpine:3.9.3
LABEL maintainer="Collabnix"

ENV DIRPATH /myfolder
WORKDIR $DIRPATH
```

Placed into *[create.sh](./create.sh)*.

##### Building Docker image

```sh
$ docker build -t workdir:v4 .
```

Placed into *[build.sh](./build.sh)*.

##### Testing current `WORKDIR` by running container

```sh
$ docker run -it workdir:v4 pwd
```

Placed into *[run.sh](./run.sh)*.


## Utils / Trivia

### Images

#### List images
```sh
$ docker images
```

#### Remove images
Below are the three command aliases:
```sh
$ docker image remove
$ docker image rm
$ docker rmi
```

### Containers

#### List containers
```sh
# List running containers
$ docker ps
# Lists all (running and stopped) containers
$ docker ps -a
```

#### Exit the container shell
Press <kbd>Ctrl</kbd> + <kbd>c</kbd> to exit the container shell. This stops the running container.

If you want to detach from a container without stopping it, type <kbd>Ctrl</kbd> + <kbd>p</kbd> then <kbd>Ctrl</kbd> + <kbd>q</kbd>. It will help you to turn interactive mode to daemon mode.

#### Remove containers
https://docs.docker.com/reference/cli/docker/container/rm/

#### Remove a container
This removes the container referenced under the link `/redis`.
```sh
$ docker rm /redis

/redis
```

#### Force-remove a running container (`--force`)
This command force-removes a running container.
```sh
$ docker rm --force redis

redis
```

The main process inside the container referenced under the link `redis` will receive `SIGKILL`, then the container will be removed.

#### Remove all stopped containers
Use the [`docker container prune`](https://docs.docker.com/reference/cli/docker/container/prune/) command to remove all stopped containers, or refer to the [`docker system prune`](https://docs.docker.com/reference/cli/docker/system/prune/) command to remove unused containers in addition to other Docker resources, such as (unused) images and networks.

Alternatively, you can use the `docker ps` with the `-q` / `--quiet` option to generate a list of container IDs to remove, and use that list as argument for the `docker rm` command.

Combining commands can be more flexible, but is less portable as it depends on features provided by the shell, and the exact syntax may differ depending on what shell is used. To use this approach on Windows, consider using PowerShell or Bash.

The example below uses `docker ps -q` to print the IDs of all containers that have exited (`--filter status=exited`), and removes those containers with the `docker rm` command:
```sh
$ docker rm $(docker ps --filter status=exited -q)
```

Or, using the `xargs` Linux utility:
```sh
$ docker ps --filter status=exited -q | xargs docker rm
```

## Troubleshooting

### Fix `permission denied` error
If you get the *permission denied* error while building the service scripts, make the script file executable:
```sh
$ chmod +x start
```

or:
```
$ chmod u+x clear
```

### Fix `failed to read dockerfile` error
If you get the *ERROR: failed to solve: failed to read dockerfile* error while running the service, probably you have your *Dockerfile* or other crucial static files missing. Run the *[create.sh](./create.sh)* script before executing the *start* command.
