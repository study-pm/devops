# Lab #14: Create a Docker Image with HEALTHCHECK instruction
https://dockerlabs.collabnix.com/beginners/dockerfile/healthcheck.html

- [Overview](#overview)
- [How does it work?](#how-does-it-work)
- [What options does `HEALTHCHECK` support?](#what-options-does-healthcheck-support)
- [Assignment](#assignment)
- [Command Line Tools](#command-line-tools)
  - [Start the service](#start-the-service)
  - [Stop the service](#stop-the-service)
  - [Underlying commands](#underlying-commands)
    - [Pre-requisite](#pre-requisite)
    - [Writing a *Dockerfile* with `HEALTHCHECK` instruction](#writing-a-dockerfile-with-healthcheck-instruction)
      - [Create Dockerfile](#create-dockerfile)
      - [Building Docker Image](#building-docker-image)
      - [Check that the nginx config file exists](#check-that-the-nginx-config-file-exists)
    - [Check if nginx is healthy](#check-if-nginx-is-healthy)
      - [Make Docker container Unhealthy and check](#make-docker-container-unhealthy-and-check)
    - [Check if nginx is healthy](#check-if-nginx-is-healthy-1)
    - [Creating the *nginx.conf* file and Making the container go healthy](#creating-the-nginxconf-file-and-making-the-container-go-healthy)
      - [Create Dockerfile](#create-dockerfile-1)
      - [Building Docker Image](#building-docker-image-1)
- [Utils / Trivia](#utils--trivia)
  - [Images](#images)
    - [Build image](#build-image)
    - [Browse image history](#browse-image-history)
    - [Remove images](#remove-images)
  - [Containers](#containers)
    - [Create (run) a container](#create-run-a-container)
    - [List containers](#list-containers)
    - [Exit the container shell](#exit-the-container-shell)
    - [Remove containers](#remove-containers)
    - [Remove a container](#remove-a-container)
    - [Force-remove a running container (`--force`)](#force-remove-a-running-container---force)
    - [Remove all stopped containers](#remove-all-stopped-containers)
  - [Volumes](#volumes)
    - [Create a volume](#create-a-volume)
    - [List volumes](#list-volumes)
    - [Inspect volume](#inspect-volume)
    - [Remove volumes](#remove-volumes)
- [Troubleshooting](#troubleshooting)
  - [Fix `permission denied` error](#fix-permission-denied-error)
  - [Fix `failed to read dockerfile` error](#fix-failed-to-read-dockerfile-error)

## Overview
The `HEALTHCHECK` directive tells Docker how to determine if the state of the container is normal. This was a new directive introduced during Docker 1.12. Before the `HEALTHCHECK` directive, the Docker engine can only determine if the container is in a state of abnormality by whether the main process in the container exits. In many cases, this is fine, but if the program enters a deadlock state, or an infinite loop state, the application process does not exit, but the container is no longer able to provide services. Prior to 1.12, Docker did not detect this state of the container and would not reschedule it, causing some containers to be unable to serve, but still accepting user requests.

The syntax look like:
```docker
HEALTHCHECK [options] CMD <command>:
```

The above syntax set the command to check the health of the container

## How does it work?
When a `HEALTHCHECK` instruction is specified in an image, the container is started with it, the initial state will be starting, and will become healthy after the `HEALTHCHECK` instruction is checked successfully. If it fails for a certain number of times, it will become unhealthy.

## What options does `HEALTHCHECK` support?
- `--interval=<interval>`: interval between two health checks, the default is 30 seconds;
- `--timeout=<time length>`: The health check command runs the timeout period. If this time is exceeded, the health check is regarded as a failure. The default is 30 seconds.
- `--retries=<number>`: When the specified number of consecutive failures, the container status is treated as unhealthy, the default is 3 times. Like `CMD`, `ENTRYPOINT`, `HEALTHCHECK` can only appear once. If more than one is written, only the last one will take effect.

## Assignment
- Writing a *Dockerfile* with `HEALTHCHECK` instruction
- Build a Docker Image
- Check that the nginx config file exists
- Check if nginx is healthy
- Make Docker container Unhealthy and check
- Create the *nginx.conf* file and Making the container go healthy

## Command Line Tools
There are two prime commands for managing (starting and stopping) the provided service.

### Start the service
The following command runs the full command sequence:
```sh
$ ./start
```

alternatively:
```sh
$ sh start
```

### Stop the service
The following command clears all of the output (removing all possible side-effects) generated by running the *start* command:
```sh
$ ./clear
```

alternatively:
```sh
$ sh clear
```

### Underlying commands
There are multiple underlying scripts used for building the service functions. The sections below describe the commands used for managing the provided service and building the necessary resources.

#### Pre-requisite
There should be the following files in your working directory:
- *Dockerfile* (committed)
- *.config* (ignored by VCS)

In case any of them missing, run the *[create.sh](./create.sh)* script before executing the *start* command.

All temporary files are removed on running the *[clear.sh](./clear.sh)* script

#### Writing a *Dockerfile* with `HEALTHCHECK` instruction
Suppose we have a simple Web service. We want to add a health check to determine if its Web service is working. We can use curl to help determine the `HEALTHCHECK` of its Dockerfile:

##### Create Dockerfile

*Dockerfile*
```docker
FROM nginx:1.13
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
EXPOSE 80
```

Here we set a check every 3 seconds (here the interval is very short for the test, it should be relatively long), if the health check command does not respond for more than 3 seconds, it is considered a failure, and use `curl -fs http://localhost/ || exit 1` as a health check command.

Placed into *[create.sh](./create.sh)*.

##### Building Docker Image

```sh
$ docker image build -t nginx:1.13 .
```
Here the `ONBUILD` instruction is read, not run, but stored for later use.

Placed into *[build.sh](./build.sh)*.

##### Check that the nginx config file exists
```sh
$ docker run --name=nginx-proxy -d \
        --health-cmd='stat /etc/nginx/nginx.conf || exit 1' \
        nginx:1.13
```

Placed into *[run.sh](./run.sh)*.

#### Check if nginx is healthy
```sh
$ docker inspect --format='{{.State.Health.Status}}' nginx-proxy
healthy
```

##### Make Docker container Unhealthy and check
```sh
$ docker exec nginx-proxy rm /etc/nginx/nginx.conf
```

#### Check if nginx is healthy
```sh
$ sleep 5; docker inspect --format='{{.State.Health.Status}}' nginx-proxy
```

#### Creating the *nginx.conf* file and Making the container go healthy
```sh
$ docker exec nginx-proxy touch /etc/nginx/nginx.conf
```
```sh
$ sleep 5; docker inspect --format='{{.State.Health.Status}}' nginx-proxy
healthy
```

##### Create Dockerfile

*Dockerfile*
```docker
FROM me/no_echo_here
```

Placed into *[create.sh](./create.sh)*.

##### Building Docker Image

```sh
$ docker build -t me/echo_here .
```

Placed into *[build.sh](./build.sh)*.

## Utils / Trivia

### Images

#### Build image
```sh
$ docker image build -t <tag> .
$ docker build -t <tag> . -f <dockerfile-name>
```

#### Browse image history
```sh
$ docker image history <image>

#### List images
```sh
# Lists all images
$ docker images
$ docker image ls

# List a specific image
$ docker images <image>
$ docker image ls <image>
$ docker images | grep "keyword(s)"
```

#### Remove images
Below are the three command aliases:
```sh
$ docker image remove <image>
$ docker image rm <image>
$ docker rmi <image>
```

### Containers

#### Create (run) a container
```sh
$ docker container run <image>
$ docker run <image>
```

#### List containers
```sh
# List running containers
$ docker ps
$ docker container ls

# Lists all (running and stopped) containers
$ docker ps -a
```

#### Exit the container shell
Press <kbd>Ctrl</kbd> + <kbd>c</kbd> to exit the container shell. This stops the running container.

If you want to detach from a container without stopping it, type <kbd>Ctrl</kbd> + <kbd>p</kbd> then <kbd>Ctrl</kbd> + <kbd>q</kbd>. It will help you to turn interactive mode to daemon mode.

#### Remove containers
https://docs.docker.com/reference/cli/docker/container/rm/

#### Remove a container
This removes the container referenced under the link `/redis`.
```sh
$ docker rm /redis

/redis
```

#### Force-remove a running container (`--force`)
This command force-removes a running container.
```sh
$ docker rm --force redis

redis
```

The main process inside the container referenced under the link `redis` will receive `SIGKILL`, then the container will be removed.

#### Remove all stopped containers
Use the [`docker container prune`](https://docs.docker.com/reference/cli/docker/container/prune/) command to remove all stopped containers, or refer to the [`docker system prune`](https://docs.docker.com/reference/cli/docker/system/prune/) command to remove unused containers in addition to other Docker resources, such as (unused) images and networks.

Alternatively, you can use the `docker ps` with the `-q` / `--quiet` option to generate a list of container IDs to remove, and use that list as argument for the `docker rm` command.

Combining commands can be more flexible, but is less portable as it depends on features provided by the shell, and the exact syntax may differ depending on what shell is used. To use this approach on Windows, consider using PowerShell or Bash.

The example below uses `docker ps -q` to print the IDs of all containers that have exited (`--filter status=exited`), and removes those containers with the `docker rm` command:
```sh
$ docker rm $(docker ps --filter status=exited -q)
```

Or, using the `xargs` Linux utility:
```sh
$ docker ps --filter status=exited -q | xargs docker rm
```

### Volumes
https://docs.docker.com/reference/cli/docker/volume/

Manage volumes. Usage: `docker volume COMMAND`

#### Create a volume
```sh
$ docker volume create
```

#### List volumes

```sh
$ docker volume ls
```

Show names and mount point destinations of volumes used by a container:
https://stackoverflow.com/questions/30133664/how-do-you-list-volumes-in-docker-containers

```sh
$ docker container inspect \
 -f '{{ range .Mounts }}{{ .Name }}:{{ .Destination }} {{ end }}' \
 <CONTAINER_ID_OR_NAME>
```

#### Inspect volume

```sh
$ docker volume inspect
```

#### Remove volumes
Remove unused local volumes:
```sh
# With confirmation dialogue
$ docker volume prune

# Without confirmation
$ docker volume prune -f
```

Remove one or more volumes:
```sh
$ docker volume rm <volumes>
```

## Troubleshooting

### Fix `permission denied` error
If you get the *permission denied* error while building the service scripts, make the script file executable:
```sh
$ chmod +x start
```

or:
```
$ chmod u+x clear
```

### Fix `failed to read dockerfile` error
If you get the *ERROR: failed to solve: failed to read dockerfile* error while running the service, probably you have your *Dockerfile* or other crucial static files missing. Run the *[create.sh](./create.sh)* script before executing the *start* command.
