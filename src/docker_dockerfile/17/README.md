# Lab 17: USER Instruction under Dockerfile
https://dockerlabs.collabnix.com/beginners/dockerfile/user.html

The `USER` directive is similar to `WORKDIR`, which changes the state of the environment and affects future layers. `WORKDIR` is to change the working directory, and `USER` is the identity of the commands such as `RUN`, `CMD` and `ENTRYPOINT`.

Of course, like `WORKDIR`, `USER` just helps you switch to the specified user. This user must be pre-established, otherwise it cannot be switched.

- [Example](#example)
- [Assignment](#assignment)
- [Command Line Tools](#command-line-tools)
  - [Start the service](#start-the-service)
  - [Stop the service](#stop-the-service)
  - [Underlying commands](#underlying-commands)
    - [Pre-requisite](#pre-requisite)
    - [Writing a Standard Dockerfile](#writing-a-standard-dockerfile)
      - [Create Dockerfile](#create-dockerfile)
      - [Building Docker Image](#building-docker-image)
      - [Run Default Docker image](#run-default-docker-image)
    - [Writing a *Dockerfile* with `USER` instruction](#writing-a-dockerfile-with-user-instruction)
      - [Create Dockerfile](#create-dockerfile-1)
      - [Building Docker Image](#building-docker-image-1)
      - [Run Custom Docker Image](#run-custom-docker-image)
- [Utils / Trivia](#utils--trivia)
  - [Images](#images)
    - [Build image](#build-image)
    - [Browse image history](#browse-image-history)
    - [Remove images](#remove-images)
  - [Containers](#containers)
    - [Create (Run) a container](#create-run-a-container)
    - [List containers](#list-containers)
    - [Exit the container shell](#exit-the-container-shell)
    - [Remove containers](#remove-containers)
    - [Remove a container](#remove-a-container)
    - [Force-remove a running container (`--force`)](#force-remove-a-running-container---force)
    - [Remove all stopped containers](#remove-all-stopped-containers)
  - [Volumes](#volumes)
    - [Create a volume](#create-a-volume)
    - [List volumes](#list-volumes)
    - [Inspect volume](#inspect-volume)
    - [Remove volumes](#remove-volumes)
- [Troubleshooting](#troubleshooting)
  - [Fix `permission denied` error](#fix-permission-denied-error)
  - [Fix `failed to read dockerfile` error](#fix-failed-to-read-dockerfile-error)

## Example
Example:
```dockerfile
RUN groupadd -r redis && useradd -r -g redis redis
USER redis
RUN [ "redis-server" ]
```

If the script executed with `root` wants to change the identity during execution, such as wanting to run a service process with an already established user, don’t use `su` or `sudo`, which requires a more cumbersome configuration. And often in the absence of TTY environment. It is recommended to use [`gosu`] (https://github.com/tianon/gosu).
```docker
# Create a redis user and use gosu to change another user to execute the command
RUN groupadd -r redis && useradd -r -g redis redis
# download gosu
RUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64" \
    && chmod +x /usr/local/bin/gosu \
    && gosu nobody true
# Set CMD and execute it as another user
CMD [ "exec", "gosu", "redis", "redis-server" ]
```

## Assignment
- Write a Standard *Dockerfile*
- Write a Custom *Dockerfile* with `USER` instruction
- Build a Default Docker Image
- Build a Custom Docker Image
- Run both images

## Command Line Tools
There are two prime commands for managing (starting and stopping) the provided service.

### Start the service
The following command runs the full command sequence:
```sh
$ ./start
```

alternatively:
```sh
$ sh start
```

### Stop the service
The following command clears all of the output (removing all possible side-effects) generated by running the *start* command:
```sh
$ ./clear
```

alternatively:
```sh
$ sh clear
```

### Underlying commands
There are multiple underlying scripts used for building the service functions. The sections below describe the commands used for managing the provided service and building the necessary resources.

#### Pre-requisite
There should be the following files in your working directory:
- *build1.Dockerfile* (committed)
- *build2.Dockerfile* (committed)

In case any of them missing, run the *[create.sh](./create.sh)* script before executing the *start* command.

All temporary files are removed on running the *[clear.sh](./clear.sh)* script

#### Writing a Standard Dockerfile
https://www.docker.com/blog/understanding-the-docker-user-instruction/

Most people take this approach when they first begin using Docker; they go with the defaults and do not specify a `USER`.

##### Create Dockerfile

*Dockerfile*
```docker
# Use the official Ubuntu image as the base
FROM ubuntu:20.04

# Print the UID and GID
CMD sh -c "echo 'Inside Container:' && echo 'User: $(whoami) UID: $(id -u) GID: $(id -g)'"
```

Placed into *[create.sh](./create.sh)*.

##### Building Docker Image

```sh
$ docker build -t default-user-image -f Dockerfile1 .
```

Placed into *[build.sh](./build.sh)*.

##### Run Default Docker image
Let’s run our first image, the one that does not provide a `USER` command. As you can see, the UID and GID are `0/0`, so the superuser is root. There are two things at work here. First, we are not defining a UID/GID in the Dockerfile so Docker defaults to the superuser. But how does it become a superuser if my account is not a superuser account? This is because the Docker Engine runs with root permissions, so containers that are built to run as root inherit the permissions from the Docker Engine.
```sh
$ docker run --rm default-user-image
Inside Container:
User: root UID: 0 GID: 0
Custom User Docker Image
```

Placed into *[run.sh](./run.sh)*.

#### Writing a *Dockerfile* with `USER` instruction
This example shows how to create a user with a `RUN` command inside a *Dockerfile* and then switch to that `USER`.

##### Create Dockerfile

*Dockerfile*
```docker
# Use the official Ubuntu image as the base
FROM ubuntu:20.04

# Create a custom user with UID 1234 and GID 1234
RUN groupadd -g 1234 customgroup && \
    useradd -m -u 1234 -g customgroup customuser

# Switch to the custom user
USER customuser

# Set the workdir
WORKDIR /home/customuser

# Print the UID and GID
CMD sh -c "echo 'Inside Container:' && echo 'User: $(whoami) UID: $(id -u) GID: $(id -g)'"
```

Placed into *[create.sh](./create.sh)*.

##### Building Docker Image

```sh
$  docker build -t custom-user-image -f Dockerfile2 .
```

Placed into *[build.sh](./build.sh)*.

##### Run Custom Docker Image
Let’s try to fix this — we really don’t want Docker containers running as root. So, in this version, we explicitly set the UID and GID for the user and group. Running this container, we see that our user is set appropriately:
```sh
$ docker run --rm custom-user-image
Inside Container:
User: customuser UID: 1234 GID: 1234
```

Placed into *[run.sh](./run.sh)*.

## Utils / Trivia

### Images

#### Build image
```sh
$ docker image build -t <tag> .
$ docker build -t <tag> . -f <dockerfile-name>
```

#### Browse image history
```sh
$ docker image history <image>

#### List images
```sh
# Lists all images
$ docker images
$ docker image ls

# List a specific image
$ docker images <image>
$ docker image ls <image>
$ docker images | grep "keyword(s)"
```

#### Remove images
Below are the three command aliases:
```sh
$ docker image remove <image>
$ docker image rm <image>
$ docker rmi <image>
```

### Containers

#### Create (Run) a container
https://docs.docker.com/reference/cli/docker/container/run/

```sh
$ docker container run <image>
$ docker run <image>
$ docker run -it --rm <image>
```

Useful flags:
- `-i`, `--interactive`: Keep STDIN open even if not attached
- `--name`:	Assign a name to the container
- `-t`, `--tty`: Allocate a pseudo-TTY
- `--rm`: 	Automatically remove the container and its associated anonymous volumes when it exits

```sh
$ docker run -it --rm <image>
```

The `--rm` flag is there to tell the Docker Daemon to clean up the container and remove the file system after the container exits. This is suitable for small testing or POC purposes.

The full option list can be found here: [docker container run](https://docs.docker.com/reference/cli/docker/container/run/)

#### List containers
```sh
# List running containers
$ docker ps
$ docker container ls

# Lists all (running and stopped) containers
$ docker ps -a
```

#### Exit the container shell
Press <kbd>Ctrl</kbd> + <kbd>c</kbd> to exit the container shell. This stops the running container.

If you want to detach from a container without stopping it, type <kbd>Ctrl</kbd> + <kbd>p</kbd> then <kbd>Ctrl</kbd> + <kbd>q</kbd>. It will help you to turn interactive mode to daemon mode.

#### Remove containers
https://docs.docker.com/reference/cli/docker/container/rm/

#### Remove a container
This removes the container referenced under the link `/redis`.
```sh
$ docker rm /redis

/redis
```

#### Force-remove a running container (`--force`)
This command force-removes a running container.
```sh
$ docker rm --force redis

redis
```

The main process inside the container referenced under the link `redis` will receive `SIGKILL`, then the container will be removed.

#### Remove all stopped containers
Use the [`docker container prune`](https://docs.docker.com/reference/cli/docker/container/prune/) command to remove all stopped containers, or refer to the [`docker system prune`](https://docs.docker.com/reference/cli/docker/system/prune/) command to remove unused containers in addition to other Docker resources, such as (unused) images and networks.

Alternatively, you can use the `docker ps` with the `-q` / `--quiet` option to generate a list of container IDs to remove, and use that list as argument for the `docker rm` command.

Combining commands can be more flexible, but is less portable as it depends on features provided by the shell, and the exact syntax may differ depending on what shell is used. To use this approach on Windows, consider using PowerShell or Bash.

The example below uses `docker ps -q` to print the IDs of all containers that have exited (`--filter status=exited`), and removes those containers with the `docker rm` command:
```sh
$ docker rm $(docker ps --filter status=exited -q)
```

Or, using the `xargs` Linux utility:
```sh
$ docker ps --filter status=exited -q | xargs docker rm
```

### Volumes
https://docs.docker.com/reference/cli/docker/volume/

Manage volumes. Usage: `docker volume COMMAND`

#### Create a volume
```sh
$ docker volume create
```

#### List volumes

```sh
$ docker volume ls
```

Show names and mount point destinations of volumes used by a container:
https://stackoverflow.com/questions/30133664/how-do-you-list-volumes-in-docker-containers

```sh
$ docker container inspect \
 -f '{{ range .Mounts }}{{ .Name }}:{{ .Destination }} {{ end }}' \
 <CONTAINER_ID_OR_NAME>
```

#### Inspect volume

```sh
$ docker volume inspect
```

#### Remove volumes
Remove unused local volumes:
```sh
# With confirmation dialogue
$ docker volume prune

# Without confirmation
$ docker volume prune -f
```

Remove one or more volumes:
```sh
$ docker volume rm <volumes>
```

## Troubleshooting

### Fix `permission denied` error
If you get the *permission denied* error while building the service scripts, make the script file executable:
```sh
$ chmod +x start
```

or:
```
$ chmod u+x clear
```

### Fix `failed to read dockerfile` error
If you get the *ERROR: failed to solve: failed to read dockerfile* error while running the service, probably you have your *Dockerfile* or other crucial static files missing. Run the *[create.sh](./create.sh)* script before executing the *start* command.
